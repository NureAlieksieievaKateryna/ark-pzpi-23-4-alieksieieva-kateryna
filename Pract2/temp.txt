МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ 
 
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ 
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ 
 
 
 
 
 
 
 
ЗВІТ 
з дисципліни «Аналіз та рефакторинг коду» 
Практична робота №2
 
 
 
 
Виконала:   	 	 	 	 	              Перевірил:  
ст. гр. ПЗПІ-23-4   	 	 	 	              старший викладач каф. ПІ  
Алєксєєва К.С.   	 	 	 	 	   Сокорчук І.П. 
 
 
 
 
 
 
 


	ХАРКІВ 2025 
	ХІД РОБОТИ

1.	  Мета роботи
Підготувати і оформити у вигляді презентації у форматі .pdf доповідь на тему: Методи рефакторингу коду програмного забезпечення. Студент повинен обрати 3 метода рефакторингу з книги  Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. 

2.	Опис виконаної роботи
У цій практичній роботі було обрано мову програмування Java. Під час виконання роботи я розглянула важливі методи рефакторингу коду. Рефакторинг — це процес покращення внутрішньої структури коду без зміни його зовнішньої поведінки, який робиться для того, щоб зробити програму простішою в підтримці, читанні, розширенні та тестуванні, а також зменшити кількість помилок і підвищити якість програмного продукту. На першому слайді який наведено у додатку Б.1 показано приклади поганого коду , в якому демонструється метод рефакторингу коду Decompose Conditional. У додатку Б.4 приведено поганий приклад коду містить велику складну умову: якщо вік користувача більше 18 років, користувач підтверджений, не заблокований, не святковий день і користувач має підписку, тоді надається доступ. Такий підхід є проблематичним, оскільки вся логіка “зашита” в один великий умовний блок і її важко швидко прочитати та зрозуміти. Не зрозуміло, що саме перевіряє кожна частина умови, що ускладнює її зміну або розширення в майбутньому. Крім того, тестувати окремі частини логіки важко, адже для перевірки однієї умови доводиться виконувати всі інші. Внаслідок цього код стає менш підтримуваним і більш схильним до помилок.
У додатку Б.5 приведено гарний приклад демонструє застосування методу декомпозиції умов. Весь складний умовний вираз винесено в окремий метод canAccess, який перевіряє, чи може користувач отримати доступ. Кожна підумова логічно виділена у власний метод або вираз: перевірка віку користувача винесена в метод isAdult, інші перевірки залишаються всередині canAccess, але тепер код читається як послідовність логічних кроків. Такий підхід робить програму більш зрозумілою і легкою для підтримки, оскільки назви методів самі пояснюють їхнє призначення. Декомпозиція умов полегшує внесення змін у майбутньому, адже змінювати правила доступу можна в одному методі, не впливаючи на інші частини програми. Крім того, код стає більш тестованим, оскільки окремі умови можна перевіряти ізольовано. Завдяки цьому підходу програма стає чистішою, структурованішою та менш схильною до помилок. У додатку Б.6 приведено поганий приклад демонструє дублювання коду в умовному блоці. Виклик log.info("Opening dashboard") повторюється як у гілці для адміністратора, так і у гілці для звичайного користувача. Це ускладнює підтримку коду, оскільки будь-яку зміну тексту логування потрібно буде виконувати в обох місцях. Крім того, дублювання підвищує ризик помилок: якщо оновити один виклик, а інший залишити без змін, поведінка програми може стати непередбачуваною. Такий код також важче читати, оскільки повторювані рядки відволікають від основної логіки вибору панелі.
Гарний приклад у додатку Б.7 показує, як усунути дублювання, винісши загальний виклик log.info("Opening dashboard") перед умовним блоком. Тепер кожна гілка умовного оператора містить тільки специфічну для неї логіку — відкриття панелі адміністратора або користувача. Завдяки цьому код став коротшим, чистішим і зрозумілішим. Зміни у логуванні тепер потрібно робити лише в одному місці, що зменшує ризик помилок. Крім того, структура коду стала більш логічною: спершу виконуються спільні дії, потім — різні, залежно від ролі користувача. Такий підхід підвищує підтримуваність і читабельність програми.
Поганий приклад у додатку Б.8 демонструє метод createUser, який приймає велику кількість параметрів: ім’я, електронну адресу, вік, місто, країну та стан верифікації користувача. Така кількість аргументів ускладнює виклик методу, підвищує ймовірність помилок через неправильний порядок передачі значень і робить код менш читабельним. Крім того, додавання нового поля або зміна існуючого потребує модифікації всіх викликів методу, що знижує підтримуваність.
Гарний приклад у додатку Б.10 демонструє використання об’єкта UserDTO, який об’єднує всі дані користувача в одному класі. Тепер метод createUser приймає лише один параметр — екземпляр UserDTO. Це значно спрощує виклик методу та покращує читабельність коду, оскільки всі пов’язані дані згруповані логічно. Крім того, додавання нових полів або змін у структурі користувача вимагає змін лише в класі UserDTO, а не в кожному виклику методу. Такий підхід підвищує підтримуваність, зменшує ризик помилок і робить код більш структурованим та зрозумілим.

ВИСНОВОК
Рефакторинг є невід’ємною частиною професійної розробки програмного забезпечення, оскільки дозволяє підтримувати код чистим, зрозумілим і гнучким. Завдяки регулярному застосуванню методів рефакторингу зменшується технічний борг та підвищується якість програмного продукту. Обрані техніки — Decompose Conditional, Consolidate Duplicate Conditional Fragments та Reduce Number of Arguments — демонструють, як невеликі структурні зміни можуть суттєво спростити логіку та зробити код більш підтримуваним. У результаті програмні системи стають надійнішими, а робота розробника — ефективнішою та продуктивнішою.
ВИКОРИСТАНІ ДЖЕРЕЛА
1. Refactoring and Design Patterns. Refactoring and Design Patterns. URL: https://refactoring.guru/ 
2.  Refactoring: Improving the Design of Existing Code. Addision-Wesley, 2018. 448 p.  

ДОДАТОК А
Відеозапис https://youtu.be/HXy2cAegRgQ
Хронологічний опис відеозапису:
00:00 – Вступ
00:09 – Що таке рефакторинг
01:00 – Методи рефакторингу
02:20 – Приклад 1: Decompose Conditional
04:40 – Приклад 2: Consolidate Duplicate Conditional Fragments
06:00 – Приклад 3: Reduce Number of Arguments

 	  










































ДОДАТОК Б
Графічні метеріали

Рисунок Б.1 – Титульний слайд
 
Рисунок Б.2 – Обрані методи рефакторингу коду
 
Рисунок Б.3 – Decompose Conditional
 
Рисунок Б.4 – Погані приклади 
 

Рисунок Б.5 – Гарний приклад


 
Рисунок Б.6 – Consolidate Duplicate Conditional Fragments поганий приклад

 
Рисунок Б.7 – Consolidate Duplicate Conditional Fragments гарний приклад

 

 Рисунок Б.7 – Опис правила
 
Рисунок Б.8 – Поганий приклад

 

Рисунок Б.9 – Пояснення поганого коду 
 

Рисунок Б.10 – Гарний приклад






