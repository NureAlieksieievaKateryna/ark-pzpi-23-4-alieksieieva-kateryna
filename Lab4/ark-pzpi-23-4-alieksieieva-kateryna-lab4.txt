МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
 
 
 
 
 
 
ЗВІТ
з дисципліни «Аналіз та рефакторинг коду»
Лабораторна робота №4
 РОЗРОБКА IoT КЛІЄНТА 
(БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)
 
 
 
Виконала:   	 	 	 	 	                  Перевірил:
ст. гр. ПЗПІ-23-4   	 	 	 	                  старший викладач каф. ПІ
Алєксєєва К.С.   	 	 	 	                  Сокорчук І.П.
 
 
 

 
 

ХАРКІВ 2025
1.	ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	17.12.2025	0.1	Створено звіт



















2.	ЗАВДАННЯ

На лабораторній роботі №4 потрібно розробити програмне забезпечення для  IoT або SmartDevice пристрою, створеного на базі будь-якої поширеної на  сьогодні платформи, придатної для реалізації вбудованих систем (Embedded  System). 
Пристрій повинен бути частиною програмної системи і повинен взаємодіяти з нею. Програмне забезпечення повинно реалізовувати розширену функціональність, що відповідає концепції IoT або SmartDevice, та забезпечувати взаємодію з  іншими частинами системи. 
Протоколи взаємодії мають відповідати сучасним вимогам до IoT або  SmartDevice. 
Для реалізації програмного забезпечення можна використовувати будь-які  технології, придатні для реалізації програмного забезпечення для вбудованих  систем.
Завдання:
1.	Розробити будову програмного забезпечення ІоТ клієнта.
2.	Створити UML діаграму прецедентів для ІоТ клієнта.
3.	Розробити бізнес логіку (математину обробку повʼязаних із предметною областю даних) та функції налаштування ІоТ клієнта.
4.	Створити діаграму діяльності для ІоТ клієнта.
5.	Створити програмну реалізацію бізнес логіки та функцій налаштування ІоТ клієнта.
6.	Перевірити роботу ІоТ клієнта.
7.	Завантажити або оновити (при потребі) створений програмний код у GitHub репозиторій для лабораторних робіт у гілку репозиторію main.
8.	Створити відеозапис демонстрації описаної у розділі 3.1 Vision & Scope. функціональності IoT клієнта та завантажити цей відеозапис у свій канал на YouTube. При завантаженні відеозапису потрібно обовʼязково встановити у налаштуваннях для цього відео українську мову як мову відео та мову субтитрів до відео.
9.	Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео.
10.	Створити звіт до лабораторної роботи.
11.	Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua.
12.	Експортувати увесь створений звіт у текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт.
Звіт повинен містити:
1.	Текстовий опис інженерних рішень.
2.	Фрагменти створеного студентом програмного коду:
•	бізнес логіки IoT клієнта  (математичної обробки повʼязаних із предметною областю даних) ;
•	налаштування IoT клієнта.
3.	Графічні ілюстрації (рисунки):
•	UML діаграма прецедентів ІоТ клієнта;
•	UML діаграма діяльності ІоТ клієнта.
Відеозапис на YouTube повинен містити:
1.	Перевірку (тестування) бізнес логіки  (математичної обробки повʼязаних із предметною областю даних) ІоТ клієнта.
2.	Перевірку (тестування) функцій налаштування ІоТ клієнта.
3.	Хронологічний опис (хвилина:секунда) процесу перевірки (тестування).














3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Реалізація функцій адміністрування серверної частини
Схема взаємодії IoT пристроїв з серверною частиною демонструє, як ESP32-клієнт обмінюється даними з сервером через WiFi. Пристрій зчитує сигнали від кнопок і надсилає запити на RESTful API серверу для перевірки підписки та логування подій. Сервер обробляє запити, зберігає інформацію у базі даних і повертає відповіді, які відображаються на LCD-дисплеї та підтверджуються звуковими сигналами. Таким чином забезпечується двостороння взаємодія: пристрій передає телеметрію і отримує статусні повідомлення від серверної частини.
 
Рисунок 3.1 - Схема взаємодії IoT пристроїв з серверною частиною

Діаграма показує взаємодію користувача, IoT-пристрою (ESP32) та серверної частини системи підписок. Користувач взаємодіє з пристроєм через кнопки для керування виконавчими механізмами. IoT-пристрій зчитує дані з сенсорів, обробляє їх, виконує локальну валідацію, генерує події та логування, а потім надсилає дані на сервер. Сервер отримує ці дані, перевіряє їх валідність, зберігає логи, надсилає статус пристрою та повідомлення про помилки назад на пристрій. Таким чином забезпечується безперервний обмін інформацією і контроль стану системи.
 
Рисунок 3.2 - UML діаграма прецедентів
 
Рисунок 3.3 - UML діаграма діяльності
    	Програма на базі ESP32 реалізує клієнтську частину IoT-системи для перевірки підписок користувачів. Спершу підключаються необхідні бібліотеки: Arduino.h для базових функцій роботи з пинами і серійним портом, WiFi.h для підключення до WiFi, HTTPClient.h для роботи з HTTP-запитами, ArduinoJson.h для обробки JSON-даних та LiquidCrystal.h для роботи з LCD-дисплеєм.

Визначаються константи для підключення до WiFi (WIFI_SSID, WIFI_PASS) та для взаємодії з сервером (SERVER_URL, USER_SUBSCRIPTION_ID, DEVICE_ID, COMPONENT_ID). Також оголошуються піни для апаратних компонентів: кнопки BTN_CHECK і BTN_CONFIG для взаємодії користувача, пін зумера BUZZER_PIN для звукових сигналів, а також піни LCD-дисплея (LCD_RS, LCD_E, LCD_D4, LCD_D5, LCD_D6, LCD_D7) для відображення інформації.
Для кнопок використовується механізм debounce, який зберігає останній стан кнопки (lastBtnState) і час останнього зчитування (lastDebounceTime), щоб уникнути випадкових спрацьовувань. Створюється об’єкт lcd для керування дисплеєм, який відповідає за Output Control Module системи.
У функції setup() налаштовуються піни для вводу і виводу, ініціалізується LCD-дисплей і встановлюється серійне з’єднання для налагодження. Після цього виконується підключення до WiFi через функцію connectWiFi(), яка контролює стан з’єднання і виводить повідомлення про успішне підключення на дисплей та серійний монітор.
Основна логіка програми розміщена у циклі loop(). Кнопка BTN_CHECK зчитується для перевірки підписки. Якщо кнопка натиснута і debounce підтвердив стабільний стан, викликається функція checkSubscriptionFromServer(). Вона надсилає GET-запит на сервер до endpoint /subscriptions/user/{USER_SUBSCRIPTION_ID} і обробляє отриманий JSON. Якщо статус підписки "ACTIVE", результат зберігається як успішний, і надсилається на сервер через функцію logUsage().

Функція logUsage() відповідає за Device Management Module, вона відправляє POST-запит на серверний endpoint /iot/log з інформацією про використання пристрою, включно з ідентифікатором пристрою, користувача та компоненту, а також результатом дії. У разі помилки або відсутності підписки спрацьовує alertBuzzer(), який подає звуковий сигнал, а на дисплеї відображається відповідне повідомлення через updateLCD().
Кнопка BTN_CONFIG дозволяє користувачу активувати режим налаштувань. При її натисканні на дисплеї відображається повідомлення "CONFIG Pressed", а зумер спрацьовує для підтвердження дії.
Таким чином, весь цикл loop() забезпечує інтеграцію Input/Sensor Abstraction Layer для обробки кнопок, Device Management Module для перевірки підписок і логування на сервер, а також Output Control Module для відображення статусу і сигналізації. Програма гарантує, що користувач отримує оперативну інформацію про стан своєї підписки, а сервер веде точний облік використання компонентів системи.
Для роботи з ESP32 та твоїм IoT-пристроєм потрібно підключити наступні бібліотеки:
#include <Arduino.h>          // Базові функції Arduino
#include <WiFi.h>             // Підключення до WiFi мереж
#include <HTTPClient.h>       // HTTP-запити до сервера
#include <ArduinoJson.h>      // Робота з JSON
#include <LiquidCrystal.h>    // LCD дисплей (HD44780)
Налаштування WiFi та серверних параметрів
#define WIFI_SSID "Wokwi-GUEST"           // Ім’я WiFi мережі
#define WIFI_PASS ""                       // Пароль WiFi

#define SERVER_URL "http://192.168.1.5:8080"  // Адреса твого сервера
#define USER_SUBSCRIPTION_ID 1                 // Ідентифікатор користувача
#define DEVICE_ID "ESP32-01"                   // Ідентифікатор пристрою
#define COMPONENT_ID 1                         // Ідентифікатор компонента

•	Ці константи використовуються для підключення та комунікації з сервером.
•	Модуль Device Management Module використовує ці значення для ідентифікації пристрою та користувача.

Оголошення PINів та апаратних компонентів
#define BTN_CHECK 4        // Кнопка для перевірки підписки
#define BTN_CONFIG 2       // Кнопка для конфігурації
#define BUZZER_PIN 15      // Піно для зумера
#define LCD_RS 16          // RS пін LCD
#define LCD_E 17           // E пін LCD
#define LCD_D4 5           // D4 пін LCD
#define LCD_D5 18          // D5 пін LCD
#define LCD_D6 19          // D6 пін LCD
#define LCD_D7 21          // D7 пін LCD

Input/Sensor Abstraction Layer: кнопки (BTN_CHECK, BTN_CONFIG) відповідають за отримання вводу користувача. Output Control Module: BUZZER_PIN та LCD піни — вихідні пристрої для відображення стану або сигналів.
Змінні для обробки кнопок
bool lastBtnState = HIGH;                 // Попередній стан кнопки
unsigned long lastDebounceTime = 0;       // Час останнього зчитування
const unsigned long debounceDelay = 50;   // Затримка для debounce
Використовується алгоритм debounce, щоб уникнути випадкових спрацьовувань кнопки.

Ініціалізація об’єктів периферії
LiquidCrystal lcd(LCD_RS, LCD_E, LCD_D4, LCD_D5, LCD_D6, LCD_D7);
Створюємо об’єкт LCD для виводу тексту. Модуль Output Control Module відповідає за відображення повідомлень.

Прототипи функцій
void connectWiFi();                     // Підключення до WiFi
void alertBuzzer();                     // Включення зумера
bool checkSubscriptionFromServer();     // Перевірка підписки на сервері
void logUsage(bool success);            // Логування використання на сервер
void updateLCD(const char* text);       // Оновлення тексту на LCD
Це дозволяє структурно розділити функціонал Device Management Module.
Налаштування пінів та початкова ініціалізація в setup()
void setup() {
  Serial.begin(115200);                // Серійний монітор для дебагу

  pinMode(BTN_CHECK, INPUT_PULLUP);   // Кнопка вводу
  pinMode(BTN_CONFIG, INPUT_PULLUP);  // Кнопка конфігурації
  pinMode(BUZZER_PIN, OUTPUT);        // Зумер

  lcd.begin(16, 2);                   // Ініціалізація LCD
  lcd.print("Initializing...");       // Початкове повідомлення

  connectWiFi();                       // Підключення до WiFi

  lcd.clear();
  lcd.print("ESP32 Ready");
}

У циклі loop() спочатку відбувається зчитування стану кнопки BTN_CHECK. Це важлива частина Input/Sensor Abstraction Layer, бо саме вона відповідає за отримання сигналу від користувача. Для того щоб уникнути випадкових спрацьовувань через механічні коливання кнопки, застосовується алгоритм debounce, який контролює час між змінами стану. Якщо стан кнопки змінюється і проходить достатньо часу (визначене debounceDelay), програма визначає, чи була кнопка натиснута.
Якщо кнопка натиснута, відбувається виклик функції checkSubscriptionFromServer(). Ця функція належить до Device Management Module, бо перевіряє активність підписки користувача через сервер. Вона відправляє HTTP GET запит, отримує JSON відповідь і аналізує статус підписки.
Після перевірки підписки результат передається у функцію logUsage(). Це теж частина Device Management Module, яка фіксує використання пристрою і надсилає інформацію на сервер у вигляді JSON. Таким чином, сервер завжди знає, коли і хто користувався пристроєм, а дані зберігаються для подальшої аналітики.
Якщо підписка не активна, спрацьовує alertBuzzer(), який відноситься до Output Control Module. Він подає короткий звуковий сигнал, щоб користувач отримав негайне повідомлення про проблему. Одночасно на LCD дисплеї відображається відповідне повідомлення через updateLCD(). Це теж модуль виводу, який дозволяє відображати текстові повідомлення, помилки чи статус системи.
Окремо обробляється кнопка BTN_CONFIG. Коли користувач її натискає, на дисплеї показується повідомлення "CONFIG Pressed", а зумер подає сигнал. Це дозволяє користувачу взаємодіяти з налаштуваннями пристрою без доступу до сервера.
Таким чином, весь цикл loop() поєднує в собі обробку вводу, взаємодію з сервером та керування вихідними пристроями. Кожен блок має своє призначення, і разом вони забезпечують повноцінну роботу IoT системи, дозволяючи користувачу отримувати інформацію в реальному часі і контролювати стан підписки.
void loop() {
  bool reading = digitalRead(BTN_CHECK);

  if (reading != lastBtnState) lastDebounceTime = millis();

  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (reading == LOW) {
     
      bool active = checkSubscriptionFromServer();

      logUsage(active);

 
      if (!active) alertBuzzer();

      delay(500); 
    }
  }

  lastBtnState = reading;

  if (digitalRead(BTN_CONFIG) == LOW) {
    updateLCD("CONFIG Pressed");
    alertBuzzer();
    delay(500);
  }

  delay(10);
}
























4. ВИСНОВКИ
Під час виконання лабораторної роботи №4 було створено програмне забезпечення для IoT-пристрою (SmartDevice) на базі платформи вбудованих систем. Реалізовано розширений функціонал, що відповідає концепції Інтернету речей, а також забезпечено взаємодію пристрою з іншими компонентами програмної системи через сучасні протоколи обміну даними. У процесі роботи було поглиблено теоретичні знання та набуті практичні навички у розробці програмного забезпечення для вбудованих систем, проєктуванні IoT-рішень та організації їх інтеграції у єдину програмну екосистему. 



















5. ВИКОРИСТАНІ ДЖЕРЕЛА
1.	ISO/IEC/IEEE 29148:2018. Systems and software engineering — Life cycle processes — Requirements engineering. Geneva, Switzerland: ISO/IEC, 2018.
2.	Wokwi - World's most advanced ESP32 Simulator. Wokwi - World's most advanced ESP32 Simulator. URL: https://wokwi.com/ (дата звернення: 23.12.2025).





















ДОДАТОК А
Відеозапис
Відеозапис 
Відеозапис презентації результатів лабораторної роботи: 
Хронологічний опис відеозапису: 
00:00 – Вступ
00:13 – Опис виконаної роботи

	
















ДОДАТОК Б
Програмний код
В.1 Код для IoT пристрою.


