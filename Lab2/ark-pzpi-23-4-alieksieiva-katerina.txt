МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
 
 
 
 
 
 
ЗВІТ
з дисципліни «Аналіз та рефакторинг коду»
Лабораторна робота №2
 
 
 
Виконала:   	 	 	 	 	                  Перевірил:
ст. гр. ПЗПІ-23-4   	 	 	 	                  старший викладач каф. ПІ
Алєксєєва К.С.   	 	 	 	                  Сокорчук І.П.
 
 
 

 
 
 
 

ХАРКІВ 2025

1.	ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	13.12.2025	0.1	Створено звіт





















2. ЗАВДАННЯ
На лабораторній роботі №2 потрібно розробити базу даних для серверної частини  програмної системи та прикладного програмного інтерфейсу. 
Завдання:
1.	Розробити будову програмної системи.
2.	Створити UML діаграму прецедентів для серверної частини системи.
3.	Створити ER діаграму даних.
4.	Розробити базу даних (БД) програмної системи.
5.	Створити діаграму структури БД.
6.	Розробити функції роботи з БД (ORM або CoRM тощо).
7.	Розробити API (REST або GraphQL, gRPC тощо) для взаємодії серверної частини з клієнтами.
8.	Створити специфікацію розробленого API.
9.	Створити програмну реалізацію розробленого API та функцій роботи з БД.
10.	Перевірити роботу створеного програмного коду серверної частини системи.







3. ОПИС ВИКОНАНОЇ РОБОТИ
Під час виконання лабораторної роботи було опрацьовано питання проєктування бази даних та серверної частини програмної системи Flexible Subscriptions Platform, призначеної для створення, аналізу та використання гнучких підписок із можливістю інтеграції IoT-пристроїв.
Серверна частина системи реалізована з використанням платформи Java Spring Boot, що забезпечує створення масштабованого та безпечного RESTful API.
Для зберігання даних використовується система керування базами даних PostgreSQL, яка гарантує надійність, транзакційність та цілісність інформації.
Архітектура програмного забезпечення побудована відповідно до принципів багатошарової архітектури, що передбачає чітке розділення відповідальностей між компонентами системи.
Структура серверного застосунку включає такі основні рівні:
•	Controller — відповідає за обробку HTTP-запитів та взаємодію з клієнтськими застосунками;
•	Service — містить бізнес-логіку, правила роботи з підписками та перевірки доступу;
•	Persistence (Repository) — забезпечує доступ до бази даних через JPA/Hibernate;
•	Security — реалізує автентифікацію та авторизацію на основі JWT-токенів.
Застосування такого підходу дозволяє ізолювати бізнес-логіку від деталей реалізації зберігання даних, підвищує гнучкість системи та спрощує її супровід і розширення.
FlexibleSubscriptions — це програмна система, яка дозволяє бізнесам створювати гнучкі, кастомні моделі підписок із набором компонентів, рівнів (tiers) та динамічних правил. Користувачі можуть обирати готові рівні або купувати індивідуально сформовані підписки, а система автоматично керує доступом, оплатами, лімітами та використанням (у тому числі через IoT-пристрої). Взаємодія між серверною частиною та клієнтськими застосунками (веб-клієнтами, бізнес-панеллю та IoT-пристроями) реалізована за архітектурним стилем REST. Обмін даними здійснюється у форматі JSON із використанням стандартних HTTP-методів (GET, POST, PUT, DELETE). Для забезпечення безпеки доступу до ресурсів системи впроваджено механізм автентифікації та авторизації на базі стандарту JWT (JSON Web Token). Після успішної автентифікації користувач або IoT-пристрій отримує токен доступу, який використовується для перевірки прав доступу до захищених API-ендпоінтів відповідно до ролі.
Модель даних системи складається з набору взаємопов’язаних сутностей, що відображають предметну область платформи гнучких підписок. Сутність User представляє користувачів системи та використовується для автентифікації і авторизації. Користувачі можуть мати різні ролі, зокрема адміністратора платформи, бізнес-користувача або клієнта. Сутність Business описує компанії, що використовують платформу для створення власних підписок. Кожен бізнес пов’язаний з конкретним користувачем-власником, має тип діяльності (наприклад, тренажерний зал, кафе або мобільний оператор) та проходить процедуру верифікації. Центральним елементом системи є сутність SubscriptionTemplate, яка представляє шаблон підписки, створений бізнесом. Шаблон містить базову ціну, тривалість дії та набір компонентів, з яких користувач може сформувати індивідуальну підписку. Сутність SubscriptionComponent описує окремі компоненти підписки, які можуть бути у вигляді сервісів, функціональних можливостей або лімітів використання. Кожен компонент має тип, модифікатор ціни та, за необхідності, обмеження на кількість використань. Факт оформлення підписки конкретним користувачем фіксується сутністю UserSubscription, яка зберігає інформацію про термін дії, фінальну вартість та статус підписки. Для контролю використання компонентів підписки застосовується сутність ComponentUsage, що дозволяє відстежувати споживання сервісів у реальному часі. 
Для підтримки апаратної частини системи передбачено сутність IoTDevice, яка представляє фізичні пристрої або клієнти, що взаємодіють із сервером. IoT-пристрої прив’язуються до конкретного бізнесу та використовують окремий механізм автентифікації для перевірки активності підписки користувача. Використання сервісів через IoT-фіксується у сутності IoTUsageLog, яка зберігає інформацію про час звернення, результат перевірки підписки та відповідний компонент. Такий підхід дозволяє реалізувати контроль доступу до послуг у режимі реального часу.
2.1 UML-діаграма прецедентів 
На етапі проєктування поведінки системи було створено UML-діаграму прецедентів, яка визначає межі програмної системи Flexible Subscriptions Platform та демонструє взаємодію між зовнішніми акторами та функціональністю серверної частини системи. Діаграма забезпечує наочне представлення основних сценаріїв використання системи та ролей учасників бізнес-процесів.
Основним актором системи є «Business», який представляє бізнес-користувача платформи. Цей актор виконує сценарії реєстрації та авторизації в системі, після чого отримує доступ до функціональності створення кастомних підписок. Бізнес-користувач може формувати підписки, налаштовуючи компоненти, редагувати та видаляти існуючі підписки, а також створювати тестові підписки з обмеженою кількістю використань. Крім того, Business має доступ до перегляду статистики продажів для аналізу попиту на підписки.
Актор «User» представляє кінцевого користувача платформи, який взаємодіє із підписками. Основні сценарії використання включають перегляд доступних підписок, оформлення та покупку підписки, її скасування, а також перегляд історії здійснених покупок. Придбання підписки передбачає виконання прецеденту «Обробка платежу», що є обов’язковим етапом для активації підписки.
Актор «PaymentGateway» відображає зовнішній платіжний сервіс. Він бере участь у сценарії обробки платежу, забезпечуючи перевірку платіжних даних, виконання фінансової транзакції та передачу результату оплати до серверної частини системи. Успішне завершення даного прецеденту необхідне для підтвердження покупки підписки.
Актор «Admin» відповідає за адміністративні функції системи. До його компетенції належить адміністрування бізнес-акаунтів, модерація підписок, створених бізнес-користувачами, та робота з аналітичною системою платформи. Admin забезпечує контроль коректності даних і стабільну роботу системи в цілому.
Таким чином, UML-діаграма прецедентів відображає основні сценарії взаємодії користувачів із системою Flexible Subscriptions Platform, демонструє розподіл ролей між акторами та забезпечує формалізований опис функціональних можливостей серверного API.
 
Рисунок 2.1 - UML-діаграма прецедентів
3.2 ER-діаграма (Entity-Relationship Diagram)
На етапі проєктування структури даних програмної системи Flexible Subscriptions Platform було розроблено ER-діаграму, яка відображає логічну модель бази даних та визначає основні сутності предметної області, їх атрибути й зв’язки між ними. Розроблена модель забезпечує підтримку гнучкого конструктора підписок, аналітики використання та інтеграції з IoT-пристроями.
Базовою сутністю системи є users, яка представляє всіх користувачів платформи незалежно від ролі. Сутність містить автентифікаційні дані та роль користувача, що використовується для розмежування доступу до функціональності системи.
Сутність business описує бізнес-акаунти, що належать користувачам із відповідною роллю. Кожен бізнес пов’язаний із сутністю users відношенням типу «один-до-багатьох», що дозволяє одному користувачу керувати кількома бізнесами. Додатково зберігається тип бізнесу та стан його верифікації.
Для реалізації механізму створення гнучких підписок у системі використовується сутність subscription_template, яка описує шаблони підписок, створені бізнесами. Кожен шаблон належить одному бізнесу та містить базові параметри підписки, такі як тривалість, базова вартість і статус активності.
Сутність subscription_component призначена для опису складових елементів підписки. Компоненти визначають окремі послуги, функціональні можливості або ліміти використання та пов’язані з конкретним шаблоном підписки відношенням «один-до-багатьох».
Факт оформлення підписки кінцевим користувачем відображається сутністю user_subscription, яка пов’язує користувача, бізнес та шаблон підписки. Дана сутність зберігає часові межі дії підписки, її поточний стан та фінальну вартість.
Для контролю реального використання компонентів підписки використовується сутність component_usage, яка фіксує кількість використань кожного компонента в межах конкретної підписки. Це дозволяє реалізувати обмеження доступу та точний облік використання сервісів.
Інтеграція з фізичними пристроями забезпечується сутністю iot_device, яка представляє зареєстровані IoT-пристрої бізнесу. Кожен пристрій має унікальний ідентифікатор та тип взаємодії (QR або NFC).
Події використання підписки через IoT-пристрої фіксуються у сутності iot_usage_log, яка зберігає інформацію про час звернення, результат перевірки та задіяні компоненти підписки. Дана сутність використовується для аудиту та аналітики використання.
Таким чином, розроблена ER-діаграма забезпечує цілісність даних, підтримує гнучку бізнес-логіку конструктора підписок та є основою для реалізації серверної частини системи на базі PostgreSQL і Spring Boot.

 
Рисунок 2.2 - ER-діаграма


3.3 Розробка бази даних програмної системи
На основі побудованої ER-діаграми було виконано фізичне проєктування бази даних для системи Flexible Subscriptions Platform. Для забезпечення цілісності даних та усунення дублювання інформації було проведено процес нормалізації схеми даних, який складався з трьох послідовних етапів.
На першому етапі, першій нормальній формі (1NF), було забезпечено атомарність всіх полів таблиць та унікальність кожного рядка. Було виділено повторювані дані в окремі таблиці, такі як компоненти підписок (subscription_component) та використання компонентів (component_usage). Кожна таблиця отримала первинний ключ для однозначної ідентифікації записів.
На другому етапі, другій нормальній формі (2NF), було усунено часткові залежності неключових атрибутів від складових ключів. Для таблиць із простим первинним ключем (id) це забезпечувалося автоматично. У таблицях із складеним унікальним ключем, таких як component_usage, значення used_count повністю залежить від комбінації user_subscription_id та component_id, що відповідає вимогам 2NF.
На третьому етапі, третій нормальній формі (3NF), було усунуто транзитивні залежності між неключовими атрибутами. Наприклад, у таблиці user_subscription всі атрибути залежать виключно від первинного ключа id та не залежать один від одного. Подібні принципи були застосовані до таблиць business, subscription_component, iot_device та iot_usage_log.
Таким чином, база даних приведена до третьої нормальної форми (3NF), що забезпечує мінімізацію дублювання даних, підтримку цілісності та ефективність обслуговування інформації.

3.4 Створення діаграми структури БД 
На основі попередньо розробленої нормалізованої моделі було спроєктовано детальну діаграму структури бази даних (рис. 2.3) для системи Flexible Subscriptions Platform. У рамках цього етапу проведено специфікацію всіх таблиць, визначено точні типи даних для кожного атрибута, встановлено обмеження на розмірність полів та зафіксовано ключові поля, що є необхідним для подальшої програмної реалізації.
Для оптимізації зберігання даних та підвищення продуктивності системи застосовано сувору типізацію рядкових атрибутів. Замість використання універсальних ресурсомістких типів, для більшості текстових полів встановлено чіткі ліміти відповідно до бізнес-логіки:
•	login — VARCHAR(50),
•	email — VARCHAR(100),
•	name у бізнес- та компонентних таблицях — VARCHAR(150),
•	device_key — VARCHAR(100).
Такий підхід дозволяє зменшити фізичний обсяг бази даних та підвищити ефективність роботи індексів при пошукових запитах. Для зберігання фінансових показників (base_price, price_modifier, final_price) використано тип NUMERIC(10,2), що забезпечує точність обчислень і запобігає похибкам округлення.
Забезпечення логічної цілісності даних реалізовано через систему обмежень та ключів. Усі первинні ключі (PK) визначені з атрибутом NOT NULL, що гарантує наявність унікального ідентифікатора для кожного запису. Структурна зв’язність між таблицями підтримується за допомогою зовнішніх ключів (FK), які забезпечують посилальну цілісність. Це унеможливлює появу «сирітських» записів, наприклад, створення підписки без прив’язки до бізнесу або користувача, чи облік використання компоненту без прив’язки до підписки.
Діаграма структури БД демонструє логічні зв’язки між таблицями:
•	Користувачі (users) можуть володіти бізнесами (business);
•	Бізнеси створюють шаблони підписок (subscription_template), які містять компоненти (subscription_component);
•	Користувачі (user) оформлюють підписки (user_subscription), що базуються на шаблонах;
•	Використання компонентів підписок фіксується у component_usage, а взаємодія з IoT-пристроями — у iot_usage_log;
•	IoT-пристрої (iot_device) належать бізнесам та логують використання підписок.
Ця структура забезпечує ефективне зберігання даних, підтримку цілісності та готовність до подальшої програмної реалізації та масштабування системи.


 
Рисунок 2.3 - Схема структури діаграми БД

3.5 Розробка функцій роботи з БД 
Далі було розроблено Api для роботи з бд.
Специфікація API :
User enpoints:
POST http://localhost:8080/client/register
POST http://localhost:8080/client/register/business
POST http://localhost:8080/client/login
Subscription enpoints:
POST  http://localhost:8080/api/user/subscriptions/create-subscription
POST http://localhost:8080/api/business/subscriptions/create
GET http://localhost:8080/api/business/subscriptions/{{businessId}}




 
Рисунок 2.3 – Api User
 
Рисунок 2.4 – Api Business Subscription



Для прикладу розглянемо реалізацію реєстрації користувача та видалення підписки. Для реєстрації користувача реалізовано:
-	 ендпоінт POST http://localhost:8080/client/register, який приймає який приймає JSON-запит у форматі:
{
  "login": "exampleLogin",
  "name": "Example Name",
  "email": "example@email.com",
  "password": "examplePassword"
}
та створює новий запис;
-  Сервіс AuthService, який перевіряє унікальність email та логіну користувача, хешує пароль, створює сутність User та зберігає її у базі даних через ORM. Генератор токенів, який після успішної реєстрації повертає клієнту accessToken та refreshToken для подальшої авторизації. Механізм обробки помилок, який повертає повідомлення у разі дублювання облікового запису або некоректних вхідних даних.
     Для реалізації створення підписки на серверній частині платформи було виконано наступне:
•	Ендпоінт: POST http://localhost:8080/api/business/subscriptions/create
o	Приймає CreateSubscriptionTemplateRequest із параметрами для нової підписки (назва, опис, базова ціна, тривалість, тип бізнесу, компоненти підписки).
o	Викликає фасад BusinessSubscriptionFacade, який координує роботу сервісів та бізнес-логіки.
•	Фасад та сервіси:
o	BusinessSubscriptionFacade забезпечує послідовність дій:
1.	Перевірка валідності даних підписки.
2.	Виклик SubscriptionTemplateService для створення шаблону підписки.
3.	Виклик SubscriptionComponentService для збереження компонентів підписки.
4.	Повернення SubscriptionTemplateResponse з ID створеної підписки, її назвою, базовою ціною та списком компонентів.
•	Сервісна логіка:
o	SubscriptionTemplateService перевіряє наявність бізнесу у системі, хешує необхідні дані (якщо потрібно), та створює новий запис у таблиці subscription_template.
o	SubscriptionComponentService додає до підписки всі компоненти (SERVICE, FEATURE, LIMIT) із зазначеними лімітами та модифікаторами ціни.
o	Всі дії відбуваються в межах транзакції, щоб забезпечити атомарність операції: якщо створення будь-якого компонента не вдасться, весь процес відкатується.
•	Обробка помилок:
o	Повертає детальні повідомлення у разі некоректних даних, дублювання назв підписок або відсутності бізнесу.
•	Результат роботи:
o	Клієнт отримує DTO SubscriptionTemplateResponse, який містить інформацію про створену підписку та її компоненти.
o	Реалізовано чіткий поділ відповідальності між контролерами, фасадами та сервісами для підтримки принципів SOLID та масштабованості системи.
   Розроблена система Flexible Subscriptions Platform забезпечує створення та управління підписками для бізнес-користувачів і кінцевих користувачів через чітко структуровані REST API. Реалізація включає нормалізовану базу даних, сервіси та фасади, що гарантують цілісність даних та атомарність операцій. Всі компоненти системи розділені за принципами SOLID, що підвищує підтримуваність і масштабованість платформи, а механізми обробки помилок і перевірки даних забезпечують надійність роботи серверної частини.
     














4. ВИСНОВКИ
У ході лабораторної роботи було спроектовано та реалізовано серверну частину системи Flexible Subscriptions Platform. Було розроблено UML-діаграму прецедентів, ER-діаграму даних та фізичну структуру бази даних з нормалізацією. Реалізовано сервіси та API для взаємодії з клієнтами, а також забезпечено роботу з базою даних через ORM. Проведене тестування підтвердило коректність роботи функцій створення та управління підписками, що забезпечує надійну та масштабовану роботу системи.














5. ВИКОРИСТАНІ ДЖЕРЕЛА
1.	ISO/IEC/IEEE 29148:2018. Systems and software engineering — Life cycle processes — Requirements engineering. Geneva, Switzerland: ISO/IEC, 2018.
2.	ДСТУ 8302:2015. Інформація та документація. Бібліографічне посилання. Загальні положення та правила складання. Київ: ДП «УкрНДНЦ», 2015.
3.	Fowler, M. Patterns of Enterprise Application Architecture. Addison-Wesley Professional, 2002.
4.	Офіційна документація фреймворку Spring Boot (версія 3.x). URL: https://spring.io/projects/spring-boot























ДОДАТОК А
Відеозапис
Відеозапис 
Відеозапис презентації результатів лабораторної роботи: 
Хронологічний опис відеозапису:
00:00 – Вступ
00:13 – Аналіз проблеми
01:55 – Аналіз аналогів
02:56 – Опис призначення системи
03:44 – Опис бізнес-логіки
05:32 – Опис функціональності серверної частини та IoT-клієнта
07:20 – Опис функціональності веб-клієнта та мобільного клієнта
08:47 – Опис програмних засобів та інструментів

	











ДОДАТОК Б
Програмний код
Б.1 Register ендпоінт в UserController
@PostMapping("register")
public void register(@RequestBody UserResisterRequest request) throws Exception {
    userFacade.registerUser(request);
}
Б.2 Метод Register у UserFacade
public void registerUser(UserResisterRequest resisterRequest) throws Exception {
    userService.existByUserName(resisterRequest.login());
    userService.registerUser(resisterRequest);
}
Б.3 Метод Register у UserService
public void registerUser(UserResisterRequest resisterRequest) throws Exception {
    if(userRepository.existsByLogin(resisterRequest.login()) && userRepository.existsByEmail(resisterRequest.email())){
        throw new Exception("User already exists with such login or email");
    }
    UserEntity saveduser = new UserEntity();
    saveduser.setLogin(resisterRequest.login());
    saveduser.setPassword(passwordEncoder.encode(resisterRequest.password()));
    saveduser.setEmail(resisterRequest.email());
    saveduser.setRole(UserRoles.CLIENT);
    userRepository.save(saveduser);
    log.info("User was created successfully");
}


Б.4 Метод createTemplate у BusinessSubscriptionFacade
@Transactional
public SubscriptionTemplateResponse createTemplate(CreateSubscriptionTemplateRequest request) {
    BusinessEntity business = businessService.findById(request.businessId());

    SubscriptionTemplateEntity template =
            subscriptionTemplateService.create(
                    business,
                    request.name(),
                    request.description(),
                    request.basePrice(),
                    request.durationDays()
            );

    return templateMapper.toDto(template);
}




